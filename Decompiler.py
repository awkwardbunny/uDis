#!/usr/bin/env python3
import logging
from dataclasses import dataclass, field
from pprint import pprint, pformat
from typing import List, Dict, Any, Union

import coloredlogs

from main import CodeBlock as ParsedCodeBlock

log = logging.getLogger(__name__)
coloredlogs.install(level="DEBUG")


@dataclass
class Bytecode:
    offset: int
    opcode: str
    operands: str
    lineno: Union[int | None]
    attr: Dict[Any, Any] = field(default_factory=dict)


@dataclass
class BasicBlock:
    label: str
    bytecode: Dict[int, Bytecode]


@dataclass
class CodeBlock:
    name: str
    source: str
    args: List[str]
    blocks: List[BasicBlock]
    line_info: Dict[int, int]

    @staticmethod
    def from_parsed_code_block(cb: ParsedCodeBlock) -> "CodeBlock":
        bc: Dict[int, Bytecode] = dict()
        for b in cb.bytecode:
            offset = b[0]
            lineno = cb.line_info[offset] if offset in cb.line_info else None
            bc[offset] = Bytecode(*b, lineno)

        bb: List[BasicBlock] = [BasicBlock("L0", bc)]
        return CodeBlock(cb.name, cb.source_file, cb.args, bb, cb.line_info)


@dataclass
class LineBuffer:
    buf: List[str] = field(default_factory=list)
    logger: logging.Logger = None
    log: bool = False

    def newline(self):
        self.append("")

    def append(self, line: str):
        self.buf.append(line)
        if self.log:
            self.logger.warning(f"OUT: {line}")

    def dump(self) -> str:
        return '\n'.join(self.buf)


class uDecompiler:
    # file_name: str
    # module_name: str
    top_desc: str
    blocks: Dict[str, CodeBlock] = dict()

    def __init__(self, blocks_in: Dict[str, ParsedCodeBlock], top_cb_name: str = "<module>"):
        log.info("Initializing decompiler...")
        log.info("* Performing initial conversion to basic blocks...")
        self.blocks = dict(map(lambda b: (b[0], CodeBlock.from_parsed_code_block(b[1])), blocks_in.items()))

        for desc, block in self.blocks.items():
            if block.name == top_cb_name:
                self.top_desc = desc
                break
        log.info(f"* Top block '{top_cb_name}' found ({self.top_desc})")

    def decompile(self, start_name: str = "<module>") -> str:
        log.info("Running decompilation...")

        # log.debug(pformat(self.blocks))

        # for now
        output = self.disassemble()
        # log.debug(output)
        return output

    def disassemble(self) -> str:
        buf = LineBuffer([], log, False)
        for block in self.blocks.values():
            buf.append(f"## Source: {block.source}")
            buf.append(f"## Name:   {block.name}")
            buf.append(f"## Args:   {block.args}")
            for bb in block.blocks:
                buf.append(f"{bb.label}:")
                for bc in bb.bytecode.values():
                    lineinfo = f"    # line {bc.lineno}" if bc.lineno is not None else ""
                    buf.append(f"  {bc.opcode} {bc.operands}{lineinfo}")
            buf.newline()
        return buf.dump()


def main(args: List[str] = None):
    import argparse
    parser = argparse.ArgumentParser(description='The actual decompiler')
    parser.add_argument('input', type=str, help='Path the the disassembly file generated by the disassembler')
    args = parser.parse_args(args)

    print("Error: Cannot run this program directly (yet)")
    # dec = uDecompiler(args.input)
    # dec.decompile()


if __name__ == "__main__":
    main()
